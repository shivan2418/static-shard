{"version":3,"sources":["../src/client/index.ts"],"sourcesContent":["/**\n * Static Shard Client Runtime\n * Generic client and types that can be imported from the package\n */\n\nimport type { ChunkMeta, Manifest, Schema } from \"../types/index.js\";\n\n// Re-export types from core types module\nexport type { ChunkMeta, Manifest, Schema };\n\n// ============================================================================\n// Operator Types\n// ============================================================================\n\nexport type StringOperators = {\n  eq?: string;\n  neq?: string;\n  contains?: string;\n  startsWith?: string;\n  endsWith?: string;\n  in?: string[];\n};\n\nexport type NumericOperators = {\n  eq?: number;\n  neq?: number;\n  gt?: number;\n  gte?: number;\n  lt?: number;\n  lte?: number;\n  in?: number[];\n};\n\n// ============================================================================\n// Client Types\n// ============================================================================\n\nexport interface ClientQueryOptions<TWhere = Record<string, unknown>, TSortable extends string = string> {\n  where?: TWhere;\n  orderBy?: TSortable | { field: TSortable; direction: \"asc\" | \"desc\" };\n  limit?: number;\n  offset?: number;\n}\n\nexport interface ClientOptions {\n  basePath: string;\n}\n\n// ============================================================================\n// Generic Client\n// ============================================================================\n\nexport class StaticShardClient<\n  TItem extends Record<string, unknown> = Record<string, unknown>,\n  TWhereClause = Record<string, unknown>,\n  TSortableField extends string = string\n> {\n  private basePath: string;\n  private manifest: Manifest | null = null;\n  private chunkCache: Map<string, TItem[]> = new Map();\n\n  constructor(options: ClientOptions) {\n    this.basePath = options.basePath.replace(/\\/$/, \"\");\n  }\n\n  /**\n   * Load the manifest file\n   */\n  private async loadManifest(): Promise<Manifest> {\n    if (this.manifest) return this.manifest;\n\n    const response = await fetch(`${this.basePath}/manifest.json`);\n    if (!response.ok) {\n      throw new Error(`Failed to load manifest: ${response.statusText}`);\n    }\n\n    this.manifest = (await response.json()) as Manifest;\n    return this.manifest;\n  }\n\n  /**\n   * Load a chunk by ID\n   */\n  private async loadChunk(chunkId: string): Promise<TItem[]> {\n    const cached = this.chunkCache.get(chunkId);\n    if (cached) return cached;\n\n    const manifest = await this.loadManifest();\n    const chunkMeta = manifest.chunks.find((c) => c.id === chunkId);\n    if (!chunkMeta) {\n      throw new Error(`Chunk not found: ${chunkId}`);\n    }\n\n    const response = await fetch(`${this.basePath}/${chunkMeta.path}`);\n    if (!response.ok) {\n      throw new Error(`Failed to load chunk ${chunkId}: ${response.statusText}`);\n    }\n\n    const records = (await response.json()) as TItem[];\n    this.chunkCache.set(chunkId, records);\n    return records;\n  }\n\n  /**\n   * Find chunk IDs that might contain matching records\n   */\n  private findCandidateChunks(manifest: Manifest, where?: TWhereClause): string[] {\n    if (!where) {\n      return manifest.chunks.map((c) => c.id);\n    }\n\n    let candidateChunks: Set<string> | null = null;\n\n    for (const [field, condition] of Object.entries(where as Record<string, unknown>)) {\n      const index = manifest.indices[field];\n\n      if (index && (typeof condition === \"string\" || typeof condition === \"number\" || typeof condition === \"boolean\")) {\n        const value = String(condition);\n        const chunks = index[value] || [];\n\n        if (candidateChunks === null) {\n          candidateChunks = new Set(chunks);\n        } else {\n          const current: Set<string> = candidateChunks;\n          candidateChunks = new Set(chunks.filter((c) => current.has(c)));\n        }\n      } else if (typeof condition === \"object\" && condition !== null && \"eq\" in condition) {\n        const value = String((condition as { eq: unknown }).eq);\n        const chunks = index?.[value] || [];\n\n        if (index) {\n          if (candidateChunks === null) {\n            candidateChunks = new Set(chunks);\n          } else {\n            const current: Set<string> = candidateChunks;\n            candidateChunks = new Set(chunks.filter((c) => current.has(c)));\n          }\n        }\n      }\n\n      // Range pruning\n      if (typeof condition === \"object\" && condition !== null) {\n        const rangeCondition = condition as { gt?: number; gte?: number; lt?: number; lte?: number };\n        const hasRangeOp = \"gt\" in rangeCondition || \"gte\" in rangeCondition || \"lt\" in rangeCondition || \"lte\" in rangeCondition;\n\n        if (hasRangeOp) {\n          const matchingChunks = manifest.chunks\n            .filter((chunk) => {\n              const range = chunk.fieldRanges[field];\n              if (!range) return true;\n\n              const min = range.min as number;\n              const max = range.max as number;\n\n              if (rangeCondition.gt !== undefined && max <= rangeCondition.gt) return false;\n              if (rangeCondition.gte !== undefined && max < rangeCondition.gte) return false;\n              if (rangeCondition.lt !== undefined && min >= rangeCondition.lt) return false;\n              if (rangeCondition.lte !== undefined && min > rangeCondition.lte) return false;\n\n              return true;\n            })\n            .map((c) => c.id);\n\n          if (candidateChunks === null) {\n            candidateChunks = new Set(matchingChunks);\n          } else {\n            const current: Set<string> = candidateChunks;\n            candidateChunks = new Set(matchingChunks.filter((c) => current.has(c)));\n          }\n        }\n      }\n    }\n\n    return candidateChunks ? [...candidateChunks] : manifest.chunks.map((c) => c.id);\n  }\n\n  /**\n   * Check if a record matches the where clause\n   */\n  private matchesWhere(record: TItem, where?: TWhereClause): boolean {\n    if (!where) return true;\n\n    for (const [field, condition] of Object.entries(where as Record<string, unknown>)) {\n      const value = record[field];\n\n      if (typeof condition !== \"object\" || condition === null) {\n        if (value !== condition) return false;\n        continue;\n      }\n\n      const ops = condition as StringOperators & NumericOperators;\n\n      if (\"eq\" in ops && value !== ops.eq) return false;\n      if (\"neq\" in ops && value === ops.neq) return false;\n      if (\"gt\" in ops && (typeof value !== \"number\" || value <= ops.gt!)) return false;\n      if (\"gte\" in ops && (typeof value !== \"number\" || value < ops.gte!)) return false;\n      if (\"lt\" in ops && (typeof value !== \"number\" || value >= ops.lt!)) return false;\n      if (\"lte\" in ops && (typeof value !== \"number\" || value > ops.lte!)) return false;\n      if (\"contains\" in ops && (typeof value !== \"string\" || !value.includes(ops.contains!))) return false;\n      if (\"startsWith\" in ops && (typeof value !== \"string\" || !value.startsWith(ops.startsWith!))) return false;\n      if (\"endsWith\" in ops && (typeof value !== \"string\" || !value.endsWith(ops.endsWith!))) return false;\n      if (\"in\" in ops && !(ops.in as unknown[])!.includes(value)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Query records\n   */\n  async query(options: ClientQueryOptions<TWhereClause, TSortableField> = {}): Promise<TItem[]> {\n    const manifest = await this.loadManifest();\n    const candidateChunkIds = this.findCandidateChunks(manifest, options.where);\n\n    const chunkPromises = candidateChunkIds.map((id) => this.loadChunk(id));\n    const chunks = await Promise.all(chunkPromises);\n\n    let results: TItem[] = [];\n    for (const chunk of chunks) {\n      for (const record of chunk) {\n        if (this.matchesWhere(record, options.where)) {\n          results.push(record);\n        }\n      }\n    }\n\n    if (options.orderBy) {\n      const field = typeof options.orderBy === \"string\" ? options.orderBy : options.orderBy.field;\n      const direction = typeof options.orderBy === \"string\" ? \"asc\" : options.orderBy.direction;\n\n      results.sort((a, b) => {\n        const aVal = a[field];\n        const bVal = b[field];\n\n        if (aVal === bVal) return 0;\n        if (aVal === null || aVal === undefined) return 1;\n        if (bVal === null || bVal === undefined) return -1;\n\n        const cmp = (aVal as string | number) < (bVal as string | number) ? -1 : 1;\n        return direction === \"asc\" ? cmp : -cmp;\n      });\n    }\n\n    const offset = options.offset || 0;\n    const limit = options.limit;\n\n    if (offset > 0 || limit !== undefined) {\n      results = results.slice(offset, limit !== undefined ? offset + limit : undefined);\n    }\n\n    return results;\n  }\n\n  /**\n   * Get a single record by primary key\n   */\n  async get(id: string | number): Promise<TItem | null> {\n    const manifest = await this.loadManifest();\n    const primaryField = manifest.schema.primaryField;\n\n    if (!primaryField) {\n      throw new Error(\"No primary field defined in schema\");\n    }\n\n    const results = await this.query({\n      where: { [primaryField]: id } as TWhereClause,\n      limit: 1,\n    });\n\n    return results[0] || null;\n  }\n\n  /**\n   * Count records matching a query\n   */\n  async count(options: { where?: TWhereClause } = {}): Promise<number> {\n    const manifest = await this.loadManifest();\n\n    if (!options.where) {\n      return manifest.totalRecords;\n    }\n\n    const results = await this.query({ where: options.where });\n    return results.length;\n  }\n\n  /**\n   * Get schema information\n   */\n  async getSchema(): Promise<Schema> {\n    const manifest = await this.loadManifest();\n    return manifest.schema;\n  }\n\n  /**\n   * Clear the chunk cache\n   */\n  clearCache(): void {\n    this.chunkCache.clear();\n  }\n}\n\n/**\n * Create a typed client instance\n */\nexport function createClient<\n  TItem extends Record<string, unknown> = Record<string, unknown>,\n  TWhereClause = Record<string, unknown>,\n  TSortableField extends string = string\n>(options: ClientOptions): StaticShardClient<TItem, TWhereClause, TSortableField> {\n  return new StaticShardClient<TItem, TWhereClause, TSortableField>(options);\n}\n"],"mappings":"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","names":[]}